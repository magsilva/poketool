head	1.2;
access;
symbols;
locks
	chaim:1.2; strict;
comment	@ * @;


1.2
date	2000.07.15.01.51.35;	author chaim;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.14.16.39.41;	author chaim;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Version before the insertion of several scenarios.
@
text
@#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <math.h>

#include "util.h"
#include "newpokelib.h"
#include "hexper.h"
#include "haval.h"

/*
- Initialize the data structures;

-- Create DS to store the maximum number of features exercised by each 
   function;
*/


int get_number_features(filename)
char *filename;
{
  FILE * desc;
  char linha[1000];
  int no_req;
  
  desc = fopen(filename,"r");
  
  if(desc == NULL)
    {
    fprintf(stderr,"heuristic: it was not possible to open file %s\n",filename);
    exit(1);
    }

 /*
   position in the end of the descriptor file less a certain quantity of bytes  */
 
  fseek(desc, (long) -50, SEEK_END);
 
  /* read number of requeriments */

  le_linha_str(linha,"Numero Total de Descritores =", desc);

  sscanf(linha,"Numero Total de Descritores = %d", &no_req);

  fclose(desc);
  return(no_req);
}

void get_info_output(output_file,output_vector,fault_ver, maxtestcases)
char * output_file;
b_vector * output_vector;
int fault_ver;
int maxtestcases;
{
  FILE * outputf;
  
  char linha[MAXLINE], * ptr_line, *ptr_aux;
  int no_case, output_res;

  outputf = fopen(output_file,"r");

  if(outputf == NULL)
    {
    fprintf(stderr,"heuristic: it was not possible to open file %s\n",output_file);
    exit(1);
    }
  
  while((ptr_line=le_linha_gen(outputf)) != NULL)
    {
    sscanf(ptr_line,"case-%d",&no_case);

    if(no_case < 1 || no_case > maxtestcases)
      error_msg(out_of_range);
          
    if(ptr_line == NULL)
      error_msg(wrong_file_desc);

    output_res = *(ptr_line+8+2*fault_ver) - '0';

    if(output_res)
       set_bit(no_case, output_vector);
    
    free(ptr_line);
    }
  
  fclose(outputf);
}

void read_features(freq,bv)
FILE * freq;
b_vector * bv;
{
 int exec_req, freq_exec, freq_tot, func_invoc, seq_i, seq_j;
 while(!feof(freq))
      {
      fscanf(freq,"%d (%d/%d) (%d %d/%d)\n",&exec_req,&freq_exec,&freq_tot,
             &func_invoc,&seq_i,&seq_j);
      set_bit(exec_req,bv);
      }
 fclose(freq);    
}

void read_cases_features(cases, testncases,maxtestcases,no_func)
FILE * cases;
Coverage ** testncases;
int maxtestcases;
int no_func;
{
  char linha[MAXLINE], * ptr_features_line, *ptr_aux;
  int no_case, feature;
  
  while(le_linha_str_exper(linha,"Case ",cases) != NULL)
    {
    sscanf(linha,"Case %d",&no_case);

    if(no_case < 1 || no_case > maxtestcases)
      error_msg(out_of_range);
    
    ptr_aux=ptr_features_line=le_linha_gen(cases);

    if(ptr_features_line == NULL)
      error_msg(wrong_file_desc);

    while(ptr_features_line != NULL)
      {
      ptr_features_line = le_no_feature(ptr_features_line,&feature);
      if(feature != -1)
	if(feature >= 1 && feature <= testncases[no_case][no_func].maxfeatures)
          set_bit(feature, &(testncases[no_case][no_func].features));
        else
          error_msg(out_of_range);
      }
    free(ptr_aux);
    }
}

Coverage ** InitializeMaxCoverage(l_funcs,criterion,maxtestcases,mcover)
element * l_funcs;
char * criterion;
int maxtestcases;
Coverage ** mcover;
{
  int i, j, no_funcs, maxfeatures, exec_features, totmaxfeatures, totexec_features;
  Coverage * maxcover, ** testscover;
  element * laux;
  char straux[1000], straux2[100];
  FILE * cases;
  
  no_funcs = list_info_size(l_funcs);

  testscover = (Coverage **) malloc(sizeof(Coverage *)*(maxtestcases+1));
  if(testscover == NULL)
    error_msg(mem_fault);

  totmaxfeatures=totexec_features=0;

  for(j=1; j <= maxtestcases; ++j)
     {
     testscover[j]= (Coverage *) malloc(sizeof(Coverage)*(no_funcs));

     if(testscover[j] == NULL)
        error_msg(mem_fault);
     }      

  maxcover = (Coverage *) malloc(sizeof(Coverage)*(no_funcs));

  if(maxcover == NULL)
    error_msg(mem_fault);
    
  printf("--------------------------------------+\n");
  printf("| Maximum Coverage for %-4s Criterion |\n",criterion);
  printf("--------------------------------------+\n");
  
  for(i=0,laux = l_funcs; laux != NULL; i++,laux=laux->next)
    {
      /* get the executed features */
      
      maxcover[i].criterion = get_crit_number(criterion);
      maxcover[i].funcname = strdup(laux->name);
      
      if(maxcover[i].funcname == NULL)
        error_msg(mem_fault);

      strcpy(straux,"./");
      strcat(straux,laux->name);
      strcat(straux,"/");
      
      get_des_file(straux2,criterion);
      strcat(straux,straux2);

      maxfeatures = get_number_features(straux);
      totmaxfeatures+=maxfeatures;

      b_vector_cons(&(maxcover[i].features),maxfeatures/BYTE+1,0);

      maxcover[i].maxfeatures=maxfeatures;
      
      strcpy(straux,"./");
      strcat(straux,laux->name);
      strcat(straux,"/");

      get_cases_file(straux2,criterion);
      strcat(straux,straux2);
      cases = fopen(straux,"r");

      if(cases == NULL)
        {
        fprintf(stderr, "pokeexper: Msg: file %scases.tes of executed features for function %s is missing\n",criterion, laux->name);
        exit(1);
        }
          
      for(j=1; j <= maxtestcases; ++j)
        {
        (testscover[j][i]).criterion = get_crit_number(criterion);
        (testscover[j][i]).funcname = strdup(laux->name);

        if((testscover[j][i]).funcname == NULL)
          error_msg(mem_fault);

        b_vector_cons(&((testscover[j][i]).features),maxfeatures/BYTE+1,0);
        (testscover[j][i]).maxfeatures=maxfeatures;
        }

      read_cases_features(cases,testscover,maxtestcases,i);
      
      fclose(cases);

      for(j=1; j <= maxtestcases; ++j)
          union_b_vector(&(maxcover[i].features),&((testscover[j][i]).features));

      exec_features = count_b_vector(&(maxcover[i].features));
      totexec_features+=exec_features;

      printf("| %-8s | %4d/%-4d (%3.3f%%)      |\n",laux->name, exec_features,maxfeatures,((double)exec_features/maxfeatures)*100);

    }
 printf("--------------------------------------+\n");
      printf("| Total    | %4d/%-4d (%3.3f%%)      |\n", totexec_features,totmaxfeatures,((double)totexec_features/totmaxfeatures)*100);
 printf("--------------------------------------+\n");

 *mcover=maxcover;
 
 return(testscover);
}

Coverage * InitializeCurCoverage(l_funcs,criterion)
element * l_funcs;
char * criterion;
{
  int i, no_funcs, maxfeatures;
  Coverage * curcover;
  element * laux;
  char straux[1000],straux2[100];
  FILE  * info;
  
  no_funcs = list_info_size(l_funcs);

  curcover = (Coverage *) malloc(sizeof(Coverage)*(no_funcs));

  for(i=0,laux = l_funcs; laux != NULL; i++,laux=laux->next)
    {
      /* get the executed features */
      
      curcover[i].criterion = get_crit_number(criterion);
      curcover[i].funcname = strdup(laux->name);
      
      if(curcover[i].funcname == NULL)
        error_msg(mem_fault);

      strcpy(straux,"./");
      strcat(straux,laux->name);
      strcat(straux,"/");
      
      get_des_file(straux2,criterion);
      strcat(straux,straux2);

      curcover[i].maxfeatures = maxfeatures = get_number_features(straux);
    
      b_vector_cons(&(curcover[i].features),maxfeatures/BYTE+1,0);
    }
  
 return(curcover);
}

void RefreshCurCoverage(curcover, l_funcs)
Coverage * curcover;
element * l_funcs;
{
 int i;
 element * laux;
 for(i=0,laux = l_funcs; laux != NULL; i++,laux=laux->next)
    reset_all(&(curcover[i].features));
}

Coverage * GetTestCoverage(tcover, testscover,testN, l_funcs)
Coverage * tcover;
Coverage ** testscover;
int testN;
element * l_funcs;
{
 int i;
 element * laux;
 
 RefreshCurCoverage(tcover, l_funcs);
 
 for(i=0,laux = l_funcs; laux != NULL; i++,laux=laux->next)
     b_vector_cpy(&(tcover[i].features),&((testscover[testN]+i)->features));

 return (tcover);
}

double CurrentCoverage(curcoverage,l_funcs)
Coverage * curcoverage;
element * l_funcs;
{
 int i;
 element * laux;
 int tot_features=0;
 int exec_features=0;
 double cover=0.0;
 
 for(i=0,laux = l_funcs; laux != NULL; i++,laux=laux->next)
   {
   tot_features += curcoverage[i].maxfeatures;
   exec_features += count_b_vector(&(curcoverage[i].features));
   }

 cover = ((double)exec_features)/((double)tot_features)*100;
 return cover;
}

int IsCoverageImproved(curcover,testcover,l_funcs)
Coverage * curcover, * testcover;
element * l_funcs;
{
 int ret = 0, i;
 element * laux;
 b_vector acc;
 
 for(i=0,laux = l_funcs; laux != NULL; i++,laux=laux->next)
    {
    b_vector_cons(&acc,curcover[i].features.nbytes,0);
    b_vector_cpy(&acc,&(curcover[i].features));
    union_b_vector(&acc,&(testcover[i].features));
    if(!is_equal_b_vector(&acc,&(curcover[i].features)))
      {
      ret = 1;
      b_vector_destroy(&acc);
      break;
      }
    b_vector_destroy(&acc);
    }
 return ret;
}

void AddFeatures(curcover,testcover,l_funcs)
Coverage * curcover, * testcover;
element * l_funcs;
{
 int ret = 0, i;
 element * laux;
 b_vector acc;
 
 for(i=0,laux = l_funcs; laux != NULL; i++,laux=laux->next)
    union_b_vector(&(curcover[i].features),&(testcover[i].features));
    
}

/*
-- Create DS containing the sets of selected test cases (1..DiffTestSets);

------ SelectDiffSets (1..DiffTestSets);
------ Bitvector Seltests;
*/

Testset * InitializeSelectDiffSets(difftestsets,maxtestcases)
int difftestsets;
int maxtestcases;
{
 int i;
 Testset * selectdiffsets;

 selectdiffsets = (Testset *) malloc(sizeof(Testset)*difftestsets);

 for(i=0; i < difftestsets; ++i)
   {
   selectdiffsets[i].no_test_set = i;  
   b_vector_cons(&(selectdiffsets[i].testcases),maxtestcases/BYTE+1,0);
   }
 
 return (selectdiffsets);
}

void SetTestNSelectDiffSets(selectdiffsets,setno,testn,difftestsets,maxtestcases)
Testset * selectdiffsets;
int setno;
int testn;
int difftestsets;
int maxtestcases;
{
  if(testn < 0 && testn > maxtestcases-1)
    error_msg(out_of_range);
      
  if(setno < 0 && setno > difftestsets-1)
    error_msg(out_of_range);

  set_bit(testn,&(selectdiffsets[setno].testcases));
}

int IsDesiredCoverage(l_funcs,curcoverage,desiredcover)
element * l_funcs;
Coverage * curcoverage;
double desiredcover;
{
 int i;
 element * laux;
 int tot_features=0;
 int exec_features=0;
 double cover=0.0;
 
 for(i=0,laux = l_funcs; laux != NULL; i++,laux=laux->next)
   {
   tot_features += curcoverage[i].maxfeatures;
   exec_features += count_b_vector(&(curcoverage[i].features));
   }

 cover = ((double)exec_features)/((double)tot_features)*100;

 if(cover >= desiredcover)
   return 1;
 else
   return 0;
}

int IsEqual(selectdiffsets,setno,difftestsets)
Testset * selectdiffsets;
int setno;
int difftestsets;
{
 int i;
 int ret = 0;
 
 if(setno < 0 && setno > difftestsets-1)
   error_msg(out_of_range);

 for(i=0; i < setno; ++i)
   {
   if(is_equal_b_vector(&(selectdiffsets[i].testcases),
                        &(selectdiffsets[setno].testcases)))
     {
     ret = 1;
     break;
     }
   }
 return ret;
}

/*
--- Select randomly a test case(SelectDiffSets[i] (1..MaxTestCases):testN;

*/

int SelectRandomTestCase(selectdiffsets,setno,maxtestcases,difftestsets)
Testset * selectdiffsets;
int setno;
int maxtestcases;
int difftestsets; 
{
 int testn, isdifferent;
 
 if(setno < 0 && setno > difftestsets-1)
   error_msg(out_of_range);

 do
   {
   testn = (rand()%maxtestcases)+1;
   if(test_bit(testn,&(selectdiffsets[setno].testcases)))
     isdifferent=0;
   else
     isdifferent=1;
   }
 while(!isdifferent);
 
 return testn;
}

/*
  
Input:
------

- Program:

- list of functions;

- Desired coverage: DesiredCover;

- Number of different sets: DiffTestSets;

- Number maximum of test cases: MaxTestCases;

Output:
-------

- Set of test cases with specified coverage;
  (sequence of test cases)
*/


element * GetFuncsNames(argv, index)
char * argv[];
int *index;
{
 element * l_funcs=NULL;

 while(!strncmp(argv[*index],"-f",2))
   {
   l_funcs = insert_list_vec_names(l_funcs,argv[*index]+2);
   ++*index;
   }
 return l_funcs;
}

void main(argc, argv)
int argc;
char * argv[];
{
 /* Local Vars */
 double desiredcover; 
 int randomsize, difftestsets, maxtestcases, setno, testn, check_eff=FALSE, fault_version;
 
 Coverage * maxcover, * curcover, *testncover, ** testscover;
 Testset * selectdiffsets;

 b_vector output_info;

 /* Auxiliary vars */

 int i,j,k, tot_certo=0, tot_exec=0, tot_fail=0,fault_reveal,no_test_cases; 
 double * vec_fault_reveal, * vec_no_test_cases, tot_fault_reveal=0, tot_no_test_cases=0;
 element * funcs, *laux;
 char * criterion, * output_file, outfilename[100];
 FILE * outfile, *adequatefile;

 
 /*
    Check the number of input parameters
 */

 if(argc < 4)
   {
   fprintf(stderr,"pokeexer -criterion [-o<output results> -v<faulty version>] -ffuncname1 [-ffunc2 ... -ffuncn] coverage diffsets testcases\n");
   fprintf(stderr,"-criterion: one of the following criteria:\n");
   fprintf(stderr,"\tpdu  : all potential du-paths\n"); 
   fprintf(stderr,"\tpu   : all potential uses\n"); 
   fprintf(stderr,"\tpudu : all potential uses/du\n"); 
   fprintf(stderr,"\tnos  : all nodes\n"); 
   fprintf(stderr,"\tarcs : all arcs\n"); 
   fprintf(stderr,"\tpuses: all p-uses\n"); 
   fprintf(stderr,"\tuses : all uses\n"); 
   fprintf(stderr,"\tdu   : all du-paths\n"); 
   fprintf(stderr,"\trand : random testing\n");
   fprintf(stderr,"<output results>: name of the file with the results of the validation of the test cases\n");
   fprintf(stderr,"<faulty version>: number of the faulty version being analyzed\n");
   fprintf(stderr,"-ffuncname1 [-ffunc2 ... -ffuncn]: function names\n");
   fprintf(stderr,"coverage : desired coverage of the test sets (if < 0, search for sets with maximum coverage)\n");
   fprintf(stderr,"coverage : if criterion is random, coverage indicates the size of the random test sets\n");
   fprintf(stderr,"diffsets : number of different test sets\n");
   fprintf(stderr,"testcases: number of different test cases\n");
   exit(1);
   }
 
 /* Check the criterion */
 
 if(get_crit_number(argv[1]+1)==0)
   error_msg(invalid_criterion);
 else
   criterion=argv[1]+1;

 /* Set info about the outputs to be determined */

 if(!strncmp(argv[2],"-o", 2))
   {
   check_eff = TRUE; /* check the effectiveness of the selected sets */
   output_file = strdup(argv[2]+2);
   if(output_file == NULL)
     error_msg(mem_fault);
   
   if(!strncmp(argv[3],"-v", 2))
     fault_version=atoi(argv[3]+2);
   else
     {
     fprintf(stderr,"pokeexper: it is missing the number of the faulty version\n");
     exit(1);
     }
  
   i=4; /* start the next parameters at 3 */
   }
 else
   i=2; /* start the next parameters at 2 */
 
 /* Get the functions Name */
 
 funcs = GetFuncsNames(argv,&i);

 /* Get desired coverage */

 if(strcmp(criterion,"rand"))
   desiredcover = atoi(argv[i]);
 else
   randomsize = atoi(argv[i]);
 ++i;
 
 /* Get number of different test sets */

 difftestsets = atoi(argv[i]);
 ++i;
 
 /* Get total number of test cases */

 maxtestcases = atoi(argv[i]);

 /* Get info about the outputs */

 if(check_eff)
   {
   b_vector_cons(&output_info,maxtestcases/BYTE+1,0);
   get_info_output(output_file,&output_info,fault_version,maxtestcases);
   }
 
 /* Check if desired cover is feasible */

 if(strcmp(criterion,"rand")) /* != rand */
   testscover = InitializeMaxCoverage(funcs,criterion,maxtestcases,&maxcover);

 if(strcmp(criterion,"rand"))
   {
   if(desiredcover > 0)
     {
       /* Search sets for a given coverage */
       if(!IsDesiredCoverage(funcs,maxcover,desiredcover))
	 {
	   fprintf(stderr,"pokeexper: desired coverage is unfeasible\n");
	   exit(1);
	 }
     }
   else
     /* Search sets for the maximum coverage */
       desiredcover = CurrentCoverage(maxcover,funcs);
   }
 else /* Random testing */
   if(randomsize > maxtestcases)
     {
      fprintf(stderr,"pokeexper: desired size of the random test set is unfeasible\n");
      exit(1);
     }	   


 /*
    Initialize Data Strutures to store, respectively, the current total 
    coverage of the selected test cases and the coverage of a particular test
    case (testn).
 */

 if(strcmp(criterion,"rand"))
   {
     curcover   = InitializeCurCoverage(funcs,criterion);
     testncover = InitializeCurCoverage(funcs,criterion);
   }

 /*
    Initialize Data Structure that store the selected test cases for each
    test set.
 */

 selectdiffsets = InitializeSelectDiffSets(difftestsets,maxtestcases);

 setno = 0;

 while(setno <= difftestsets-1)
   {
   unsigned int lastseed=0, seed=0;
   
   /* Select new seed */
   
   seed = time(NULL);

   if(seed == lastseed)
     {
     lastseed=seed;
     seed +=(unsigned int) clock();
     }
   else
     lastseed=seed;
     
   /* printf("\nNew seed: %d\n",(unsigned int) seed); */

   srand((unsigned int) seed);
  
   if(strcmp(criterion,"rand"))
     {
       RefreshCurCoverage(curcover,funcs);
       while(!IsDesiredCoverage(funcs,curcover,desiredcover))
	 {
	   testn = SelectRandomTestCase(selectdiffsets,setno,maxtestcases);

	   testncover = GetTestCoverage(testncover,testscover,testn,funcs);

	   if(IsCoverageImproved(curcover,testncover,funcs))
	     {
	       AddFeatures(curcover,testncover,funcs);
	       SetTestNSelectDiffSets(selectdiffsets,setno,testn,difftestsets,maxtestcases);
	     }
	 }

       if(IsEqual(selectdiffsets,setno,difftestsets))
          reset_all(&(selectdiffsets[setno].testcases));
       else
         ++setno;
     }
   else       
     { /* Random selection */
       int maxrandom = randomsize;
       int notestcase = 0;

       while(notestcase < maxrandom)
	 {
	   testn = SelectRandomTestCase(selectdiffsets,setno,maxtestcases);
	   SetTestNSelectDiffSets(selectdiffsets,setno,testn,difftestsets,maxtestcases);

	   ++notestcase;
      	 }
      
       if(IsEqual(selectdiffsets,setno,difftestsets))
          reset_all(&(selectdiffsets[setno].testcases));
       else
         ++setno;
     }

   }

 if(check_eff)
   {
   printf("\n-fail ");
   for(i=1; i <= maxtestcases; ++i)
     if(test_bit(i, &output_info))
	  printf("%d ", i); ++tot_exec;
  
   if(strcmp(criterion,"rand"))
     {
     printf("\nCheckfault detection  ability\n\n");
     for(k=0,laux = funcs; laux != NULL; k++,laux=laux->next)
       {
	 printf("\n* * %s * *\n",laux->name);
	 for(j=0; j <= maxcover[k].maxfeatures; ++j)
	   {
	     tot_fail=tot_certo=0;
	     if(!test_bit(j,&(maxcover[k].features)))
	       continue;

	     for(i=1; i <= maxtestcases; ++i)
	       if(!test_bit(i, &output_info))
		 if(test_bit(j,&((testscover[i][k]).features)))
		   { ++tot_certo; /* printf(" %d ",i); */}

	     printf("total succ %d: %d\n",j,tot_certo);
	     for(i=1; i <= maxtestcases; ++i)
	       if(test_bit(i, &output_info))
		 if(test_bit(j,&((testscover[i][k]).features)))
		   {++tot_fail;/* printf(" %d ",i); */}
	     printf("total fail %d: %d\n",j,tot_fail);
    
	     printf("fault detection ability of %d: %1.3f\n\n", j, ((double)tot_fail)/(tot_fail+tot_certo));
	   }
       }
     }
   }

  if(check_eff)
    {
     strcpy(outfilename,criterion);
     strcat(outfilename,"effect.tes");

     outfile  = fopen(outfilename,"w");
     if(outfile == NULL)
       {
       fprintf(stderr,"pokeexper: it was not possible to open file \"outfilename\"\n");
       exit(1);
       }

   if(strcmp(criterion,"rand"))   
     fprintf(outfile,"Effectiveness of Selected Test Sets of Coverage %3.2f\n",((double)count_b_vector(&(maxcover->features))/maxcover->maxfeatures)*100);

     strcpy(outfilename,criterion);
     strcat(outfilename,"adequate.tes");

     adequatefile  = fopen(outfilename,"w");
     if(adequatefile == NULL)
       {
       fprintf(stderr,"pokeexper: it was not possible to open file \"outfilename\"\n");
       exit(1);
       }
   
     fprintf(adequatefile,"Adequate Test Sets for %s Criterion\n\n",criterion);
    }


   vec_fault_reveal = (double *) malloc(sizeof(double)*difftestsets);
   if(vec_fault_reveal == NULL)
     error_msg(mem_fault);

  vec_no_test_cases = (double *) malloc(sizeof(double)*difftestsets);
   if(vec_no_test_cases == NULL)
     error_msg(mem_fault);

 for(setno=0; setno <= difftestsets-1; ++setno)
   {

   fault_reveal=0;   
   no_test_cases = count_b_vector(&(selectdiffsets[setno].testcases));
   printf("\nTest set # %d (%d test cases) :",setno+1,no_test_cases);

   /* Size info */
   
   tot_no_test_cases+=no_test_cases;
   vec_no_test_cases[setno]=no_test_cases;
      
   fprintf(adequatefile,"\n -testset %d -fail ",no_test_cases);

   for(i=1; i <= maxtestcases; ++i)
     {
      if(test_bit(i,&(selectdiffsets[setno].testcases)))
        if(check_eff)
          if(test_bit(i, &output_info))	    
            {
            fault_reveal++;
            fprintf(adequatefile,"%d ",i);
	    }
     }

   fprintf(adequatefile,"-succ ");
   
   for(i=1; i <= maxtestcases; ++i)
     {
      if(test_bit(i,&(selectdiffsets[setno].testcases)))
        if(check_eff)
          {
	  /*fprintf(adequatefile,"%d ",i);*/
          if(!test_bit(i, &output_info))	    
            fprintf(adequatefile,"%d ",i);
	  }
     }
   
   if(check_eff)
     fprintf(adequatefile,"\n\n");

   tot_fault_reveal+=fault_reveal;
   vec_fault_reveal[setno]=fault_reveal;

   if(check_eff)
     {
     if(fault_reveal)
       printf("Test set #%d is EFFECTIVE: %d test cases reveal the fault\n",setno+1,fault_reveal);
     else
       printf("Test set #%d is ineffective\n",setno+1);

     fprintf(outfile,"%d\t%d\t%d\n",setno+1,fault_reveal,no_test_cases);
     }
   
   printf("\n");
  }
 if(check_eff)
   {
     /* Determine Standard deviation */
     /* Averages */

     double eff_dev, eff_max, eff_min, acum_fault_reveal = 0;
     double size_dev, size_max, size_min, acum_no_test_cases = 0;

     tot_fault_reveal/=difftestsets;
     tot_no_test_cases/=difftestsets;
     eff_max = eff_min = vec_fault_reveal[0];
     size_max = size_min = vec_no_test_cases[0];
     
     for(setno=0; setno <= difftestsets-1; ++setno)
        {
	  acum_fault_reveal+=pow(vec_fault_reveal[setno]-tot_fault_reveal,2);
	  acum_no_test_cases+=pow(vec_no_test_cases[setno]-tot_no_test_cases,2);

          eff_max = MAX(eff_max,vec_fault_reveal[setno]);
          eff_min = MIN(eff_min,vec_fault_reveal[setno]);
          size_max = MAX(size_max,vec_no_test_cases[setno]);
          size_min = MIN(size_min,vec_no_test_cases[setno]);

        }
     
     /* find deviation */

     eff_dev = sqrt(acum_fault_reveal/(difftestsets-1));
     size_dev = sqrt(acum_no_test_cases/(difftestsets-1));

     fprintf(outfile,"\n* * Effectiveness Data * *\n");
     fprintf(outfile,"\nAverage=%3.3f\n", tot_fault_reveal);
     fprintf(outfile,"\nStd deviation=%3.3f\n", eff_dev);
     fprintf(outfile,"\nMax=%3.3f Min=%3.3f\n", eff_max, eff_min);

     fprintf(outfile,"\n* * Size Data * *\n");
     fprintf(outfile,"\nAverage=%3.3f\n", tot_no_test_cases);
     fprintf(outfile,"\nStd deviation=%3.3f\n", size_dev);
     fprintf(outfile,"\nMax=%3.3f Min=%3.3f\n", size_max, size_min);
 
     free(vec_fault_reveal);
     free(vec_no_test_cases);
     fclose(outfile);
     fclose(adequatefile);
   }
}









@


1.1
log
@Initial revision
@
text
@d4 2
d7 1
d10 1
a18 128
int get_crit_number(crit)
char *crit;
{
int ret;

  if(!strcmp(crit,"pudu"))
    /* == pudu */
    ret=3; 
  else
    /* == pu */
    if(!strcmp(crit,"pu"))
      ret=2; 
    else
      if(!strcmp(crit,"pdu"))
        /* == nos */
        ret=1;  
      else
        if(!strcmp(crit,"arcs"))
          /* == arcs */
          ret=4;  
        else
          if(!strcmp(crit,"nos"))
            /* == nos */
            ret=5;  
          else
            if(!strcmp(crit,"uses"))
              /* == uses */
              ret=7;  
            else
              if(!strcmp(crit,"puses"))
                /* == puses */
                ret=6;  
              else
                if(!strcmp(crit,"du"))
                  /* == puses */
                  ret=8;  
                else
                  ret=-1;

 return ret;
}

char * get_des_file(filename,crit)
char *filename;
char *crit;
{
  if(!strcmp(crit,"pudu"))
    /* == pudu */
    strcpy(filename,"des_pudu.tes");
  else
    /* == pu */
    if(!strcmp(crit,"pu"))
      strcpy(filename,"des_pu.tes");
    else
      if(!strcmp(crit,"pdu"))
        /* == nos */
        strcpy(filename,"des_pdu.tes");
      else
        if(!strcmp(crit,"arcs"))
          /* == arcs */
          strcpy(filename,"des_arc.tes");
        else
          if(!strcmp(crit,"nos"))
            /* == nos */
            strcpy(filename,"des_nos.tes");
          else
            if(!strcmp(crit,"uses"))
              /* == uses */
              strcpy(filename,"des_all_uses.tes");
            else
              if(!strcmp(crit,"puses"))
                /* == puses */
                strcpy(filename,"des_p_uses.tes");
              else
                if(!strcmp(crit,"du"))
                  /* == puses */
                  strcpy(filename,"des_all_du_paths.tes");
                else
                  error("pokeexer: Error: invalid criterion\n");

}

char * get_freq_file(filename,crit,testn)
char *filename;
char *crit;
int testn;
{
  char str[100];
  
  if(!strcmp(crit,"pudu"))
    /* == pudu */
    strcpy(filename,"pudufreq");
  else
    /* == pu */
    if(!strcmp(crit,"pu"))
      strcpy(filename,"pufreq");
    else
      if(!strcmp(crit,"pdu"))
        /* == nos */
        strcpy(filename,"pdufreq");
      else
        if(!strcmp(crit,"arcs"))
          /* == arcs */
          strcpy(filename,"arcfreq");
        else
          if(!strcmp(crit,"nos"))
            /* == nos */
            strcpy(filename,"nosfreq");
          else
            if(!strcmp(crit,"uses"))
              /* == uses */
              strcpy(filename,"usesfreq");
            else
              if(!strcmp(crit,"puses"))
                /* == puses */
                strcpy(filename,"pusesfreq");
              else
                if(!strcmp(crit,"du"))
                  /* == puses */
                  strcpy(filename,"dupathsfreq");
                else
                  error_msg();

 sprintf(str,"%d.tes",testn);

 strcat(filename,str);
 
}
d50 40
d104 35
a138 1
Coverage * InitializeMaxCoverage(l_funcs,criterion,maxtestcases)
d142 1
d144 2
a145 3
  int i, j, exec_req, freq_exec, freq_tot, seq_i, seq_j, no_funcs,
      exec_features, maxfeatures;
  Coverage * maxcover;
d148 1
a148 1
  FILE * freq;
d152 14
d167 4
a170 1
  
d193 1
d198 14
d215 2
a216 7
        strcpy(straux,"./");
        strcat(straux,laux->name);
        strcat(straux,"/");

        get_freq_file(straux2,criterion,j);
        strcat(straux,straux2);
        freq = fopen(straux,"r");
d218 5
a222 9
        if(freq == NULL)
          {
            /*fprintf(stderr, "pokeexper: Msg: file of executed features for test case %d of function %s is missing\n",j, laux->name);*/
          continue;
          }

        read_features(freq,&(maxcover[i].features));
        fclose(freq);
        
d225 7
d233 2
a234 1
                                     
d239 6
a244 2
  
 return(maxcover);
d296 3
a298 2
Coverage * GetTestCoverage(testcover, testN, l_funcs,criterion)
Coverage * testcover;
a300 1
char * criterion;
d302 1
a302 1
 int i, exec_req, freq_exec, freq_tot, seq_i, seq_j;
a303 2
 char freqfile[1000], str[100];
 FILE * freq;
d305 1
a305 1
 RefreshCurCoverage(testcover, l_funcs);
d308 1
a308 7
    {
    /* find the name of the frequency file */
      strcpy(freqfile,"./");
      strcat(freqfile,laux->name);
      strcat(freqfile,"/");

      get_freq_file(str,criterion,testN);
d310 1
a310 15
      strcat(freqfile,str);
      freq = fopen(freqfile,"r");

      if(freq == NULL)
        {
          /* fprintf(stderr, "pokeexper: Msg: file of frequencies for test case %d of function %s is missing\n", laux->name, testN); */
        continue;
        }

      read_features(freq,&(testcover[i].features));
    
      fclose(freq);
    }    

 return (testcover);
a516 1
 *index=2;
d529 5
a533 6
 int i;
 element * funcs;
 char * criterion;
 double desiredcover;
 int difftestsets, maxtestcases, setno, testn;
 Coverage * maxcover, * curcover, *testncover;
d535 12
a546 1
   
d553 13
a565 1
   fprintf(stderr,"pokeexer -criterion -ffuncname1 [-ffunc2 ... -ffuncn] coverage diffsets testcases\n");
d567 2
a568 1
   fprintf(stderr,"coverage : desired coverage of the test sets (if < 0, search for sets with maximum coverage\n");
d576 2
a577 2
 if(get_crit_number(argv[1]+1)<0)
   error("pokeexer: Error: invalid criterion\n");
d581 22
d609 4
a612 1
 desiredcover = atoi(argv[i]);
d624 8
d634 2
a635 1
 maxcover = InitializeMaxCoverage(funcs,criterion,maxtestcases);
d637 1
a637 1
 if(desiredcover > 0)
d639 1
a639 2
   /* Search sets for a given coverage */
   if(!IsDesiredCoverage(funcs,maxcover,desiredcover))
d641 6
a646 2
     fprintf(stderr,"pokeexper: desired coverage is unfeasible\n");
      exit(1);
d648 3
d652 7
a658 3
 else
   /* Search sets for the maximum coverage */
   desiredcover = CurrentCoverage(maxcover,funcs);
d666 5
a670 2
 curcover   = InitializeCurCoverage(funcs,criterion);
 testncover = InitializeCurCoverage(funcs,criterion);
d683 2
d686 65
a750 4
   srand((unsigned int) setno);
   RefreshCurCoverage(curcover,funcs);
   printf("Test set # %d :",setno);
   while(!IsDesiredCoverage(funcs,curcover,desiredcover))
d752 27
a778 2
     testn = SelectRandomTestCase(selectdiffsets,setno,maxtestcases);
     testncover = GetTestCoverage(testncover,testn,funcs,criterion);
d780 7
a786 1
     if(IsCoverageImproved(curcover,testncover,funcs))
d788 2
a789 3
       AddFeatures(curcover,testncover,funcs);
       SetTestNSelectDiffSets(selectdiffsets,setno,testn,difftestsets,maxtestcases);
       printf(" %d (%3.2f)",testn,CurrentCoverage(curcover,funcs));
d791 49
d842 3
a844 1
   if(IsEqual(selectdiffsets,setno,difftestsets))
d846 7
a852 2
      printf("\n** Repeated **\n");
      reset_all(&(selectdiffsets[setno].testcases));
d854 8
a861 1
   else
d863 6
a868 2
     printf("\n** Good: set of %d test cases **\n", count_b_vector(&(selectdiffsets[setno].testcases)));
     ++setno;
d870 47
a918 1

@
